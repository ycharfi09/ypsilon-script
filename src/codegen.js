/**
 * Ypsilon Script Code Generator
 * Transpiles AST to Arduino C++ code
 */

class CodeGenerator {
  constructor(ast) {
    this.ast = ast;
    this.setupStatements = [];
    this.loopStatements = [];
    this.globalVariables = [];
    this.functions = [];
    this.indent = 0;
    this.needsSerial = false;
  }

  generate() {
    // First pass: analyze the AST to detect features we need
    this.analyzeAST(this.ast);
    
    // Second pass: process and generate code
    this.processProgram(this.ast);
    return this.buildArduinoCode();
  }

  analyzeAST(node) {
    if (!node) return;
    
    if (node.type === 'CallExpression' && node.callee.name === 'print') {
      this.needsSerial = true;
    }
    
    // Recursively check all nodes
    if (Array.isArray(node)) {
      node.forEach(n => this.analyzeAST(n));
    } else if (typeof node === 'object') {
      Object.values(node).forEach(value => {
        if (value && typeof value === 'object') {
          this.analyzeAST(value);
        }
      });
    }
  }

  processProgram(program) {
    for (const stmt of program.body) {
      this.processTopLevelStatement(stmt);
    }
  }

  processTopLevelStatement(stmt) {
    if (stmt.type === 'FunctionDeclaration') {
      // Special handling for setup() and loop()
      if (stmt.name === 'setup') {
        this.setupStatements = stmt.body;
      } else if (stmt.name === 'loop') {
        this.loopStatements = stmt.body;
      } else {
        this.functions.push(stmt);
      }
    } else if (stmt.type === 'VariableDeclaration') {
      this.globalVariables.push(stmt);
    } else {
      // Top-level statements go into setup
      this.setupStatements.push(stmt);
    }
  }

  buildArduinoCode() {
    let code = '// Generated by Ypsilon Script Compiler\n';
    code += '// https://github.com/ycharfi09/ypsilon-script\n\n';
    
    // Add Arduino library includes
    code += '#include <Arduino.h>\n\n';

    // Global variables
    if (this.globalVariables.length > 0) {
      code += '// Global Variables\n';
      for (const varDecl of this.globalVariables) {
        code += this.generateVariableDeclaration(varDecl) + '\n';
      }
      code += '\n';
    }

    // Function declarations
    if (this.functions.length > 0) {
      code += '// Function Declarations\n';
      for (const func of this.functions) {
        code += this.generateFunctionDeclaration(func) + '\n\n';
      }
    }

    // Setup function
    code += 'void setup() {\n';
    this.indent = 1;
    
    // Add Serial.begin if print() is used
    if (this.needsSerial) {
      code += this.getIndent() + 'Serial.begin(9600);\n';
    }
    
    if (this.setupStatements.length > 0) {
      for (const stmt of this.setupStatements) {
        code += this.generateStatement(stmt);
      }
    }
    this.indent = 0;
    code += '}\n\n';

    // Loop function
    code += 'void loop() {\n';
    this.indent = 1;
    if (this.loopStatements.length > 0) {
      for (const stmt of this.loopStatements) {
        code += this.generateStatement(stmt);
      }
    }
    this.indent = 0;
    code += '}\n';

    return code;
  }

  generateFunctionDeclaration(func) {
    // Check if function has a return statement with a value
    const hasReturnValue = this.hasReturnValue(func.body);
    const returnType = hasReturnValue ? 'int' : 'void';
    
    let code = `${returnType} ${func.name}(`;
    code += func.params.map(p => `int ${p}`).join(', ');
    code += ') {\n';
    
    this.indent++;
    for (const stmt of func.body) {
      code += this.generateStatement(stmt);
    }
    this.indent--;
    
    code += '}';
    return code;
  }

  hasReturnValue(body) {
    for (const stmt of body) {
      if (stmt.type === 'ReturnStatement' && stmt.argument) {
        return true;
      }
      // Check nested blocks
      if (stmt.type === 'IfStatement') {
        if (this.hasReturnValue(stmt.consequent)) return true;
        if (stmt.alternate && this.hasReturnValue(stmt.alternate)) return true;
      }
      if (stmt.type === 'WhileStatement' || stmt.type === 'ForStatement') {
        if (this.hasReturnValue(stmt.body)) return true;
      }
    }
    return false;
  }

  generateStatement(stmt) {
    switch (stmt.type) {
      case 'VariableDeclaration':
        return this.getIndent() + this.generateVariableDeclaration(stmt) + '\n';
      case 'ExpressionStatement':
        return this.getIndent() + this.generateExpression(stmt.expression) + ';\n';
      case 'IfStatement':
        return this.generateIfStatement(stmt);
      case 'WhileStatement':
        return this.generateWhileStatement(stmt);
      case 'ForStatement':
        return this.generateForStatement(stmt);
      case 'ReturnStatement':
        return this.generateReturnStatement(stmt);
      default:
        return '';
    }
  }

  generateVariableDeclaration(varDecl) {
    const type = varDecl.kind === 'const' ? 'const int' : 'int';
    let code = `${type} ${varDecl.name}`;
    if (varDecl.init) {
      code += ' = ' + this.generateExpression(varDecl.init);
    }
    return code + ';';
  }

  generateIfStatement(stmt) {
    let code = this.getIndent() + 'if (' + this.generateExpression(stmt.test) + ') {\n';
    this.indent++;
    for (const s of stmt.consequent) {
      code += this.generateStatement(s);
    }
    this.indent--;
    code += this.getIndent() + '}';
    
    if (stmt.alternate) {
      code += ' else {\n';
      this.indent++;
      for (const s of stmt.alternate) {
        code += this.generateStatement(s);
      }
      this.indent--;
      code += this.getIndent() + '}';
    }
    
    code += '\n';
    return code;
  }

  generateWhileStatement(stmt) {
    let code = this.getIndent() + 'while (' + this.generateExpression(stmt.test) + ') {\n';
    this.indent++;
    for (const s of stmt.body) {
      code += this.generateStatement(s);
    }
    this.indent--;
    code += this.getIndent() + '}\n';
    return code;
  }

  generateForStatement(stmt) {
    // Handle range-based for loops
    let code = '';
    const iterator = stmt.iterator;
    
    if (iterator.type === 'CallExpression' && iterator.callee.name === 'range') {
      const args = iterator.arguments;
      let start = '0';
      let end = '0';
      let step = '1';
      let comparison = '<';
      
      if (args.length === 1) {
        end = this.generateExpression(args[0]);
      } else if (args.length === 2) {
        start = this.generateExpression(args[0]);
        end = this.generateExpression(args[1]);
      } else if (args.length === 3) {
        start = this.generateExpression(args[0]);
        end = this.generateExpression(args[1]);
        step = this.generateExpression(args[2]);
        
        // Handle negative step (countdown)
        if (args[2].type === 'UnaryExpression' && args[2].operator === '-') {
          comparison = '>';
        }
      }
      
      code = this.getIndent() + `for (int ${stmt.variable} = ${start}; ${stmt.variable} ${comparison} ${end}; ${stmt.variable} += ${step}) {\n`;
    } else {
      // Fallback
      code = this.getIndent() + `for (int ${stmt.variable} = 0; ${stmt.variable} < 10; ${stmt.variable}++) {\n`;
    }
    
    this.indent++;
    for (const s of stmt.body) {
      code += this.generateStatement(s);
    }
    this.indent--;
    code += this.getIndent() + '}\n';
    return code;
  }

  generateReturnStatement(stmt) {
    let code = this.getIndent() + 'return';
    if (stmt.argument) {
      code += ' ' + this.generateExpression(stmt.argument);
    }
    return code + ';\n';
  }

  generateExpression(expr) {
    switch (expr.type) {
      case 'Literal':
        return this.generateLiteral(expr);
      case 'Identifier':
        return expr.name;
      case 'BinaryExpression':
        return this.generateBinaryExpression(expr);
      case 'UnaryExpression':
        return this.generateUnaryExpression(expr);
      case 'AssignmentExpression':
        return this.generateExpression(expr.left) + ' = ' + this.generateExpression(expr.right);
      case 'CallExpression':
        return this.generateCallExpression(expr);
      case 'MemberExpression':
        return this.generateExpression(expr.object) + '.' + expr.property;
      default:
        return '';
    }
  }

  generateLiteral(expr) {
    if (expr.valueType === 'string') {
      return `"${expr.value}"`;
    } else if (expr.valueType === 'boolean') {
      return expr.value ? 'true' : 'false';
    }
    return String(expr.value);
  }

  generateBinaryExpression(expr) {
    const left = this.generateExpression(expr.left);
    const right = this.generateExpression(expr.right);
    
    // Convert Python/JS operators to C++
    const operatorMap = {
      'and': '&&',
      'or': '||',
      '==': '==',
      '!=': '!=',
      '<': '<',
      '>': '>',
      '<=': '<=',
      '>=': '>=',
      '+': '+',
      '-': '-',
      '*': '*',
      '/': '/',
      '%': '%'
    };
    
    const op = operatorMap[expr.operator] || expr.operator;
    return `(${left} ${op} ${right})`;
  }

  generateUnaryExpression(expr) {
    const operatorMap = {
      'not': '!',
      '-': '-'
    };
    const op = operatorMap[expr.operator] || expr.operator;
    return `${op}(${this.generateExpression(expr.argument)})`;
  }

  generateCallExpression(expr) {
    const callee = expr.callee.name || this.generateExpression(expr.callee);
    const args = expr.arguments.map(arg => this.generateExpression(arg)).join(', ');
    
    // Map built-in functions to Arduino equivalents
    const builtinMap = {
      'print': 'Serial.println',
      'delay': 'delay',
      'millis': 'millis',
      'pinMode': 'pinMode',
      'digitalWrite': 'digitalWrite',
      'digitalRead': 'digitalRead',
      'analogRead': 'analogRead',
      'analogWrite': 'analogWrite',
      'range': 'range', // handled specially in for loops
      'HIGH': 'HIGH',
      'LOW': 'LOW',
      'INPUT': 'INPUT',
      'OUTPUT': 'OUTPUT',
      'INPUT_PULLUP': 'INPUT_PULLUP'
    };
    
    const funcName = builtinMap[callee] || callee;
    
    // Mark that we need Serial if print is used
    if (callee === 'print') {
      this.needsSerial = true;
    }
    
    return `${funcName}(${args})`;
  }

  getIndent() {
    return '  '.repeat(this.indent);
  }
}

module.exports = { CodeGenerator };

/**
 * Ypsilon Script Code Generator - OOP, Strictly-Typed, Brace-Based
 * Transpiles AST to Arduino C++ code
 */

const { Config } = require('./config');
const { generatePWMSetup } = require('./pwm');

class CodeGenerator {
  constructor(ast, options = {}) {
    this.ast = ast;
    this.basePath = options.basePath || process.cwd();
    this.fileReader = options.fileReader || null;
    this.classes = [];
    this.enums = [];
    this.structs = [];
    this.globalVariables = [];
    this.functions = [];
    this.setupStatements = [];
    this.loopStatements = [];
    this.onBlocks = [];
    this.interrupts = [];
    this.signals = [];
    this.tasks = [];
    this.useStatements = [];
    this.loadStatements = [];
    this.modules = []; // .ys modules loaded
    this.aliases = [];
    this.configBlock = null;
    this.config = null; // Will be initialized after processing
    this.reactVars = [];
    this.indent = 0;
    this.needsSerial = false;
    this.timeVarCounter = 0;
  }

  generate() {
    // First pass: analyze the AST to detect features we need
    this.analyzeAST(this.ast);
    
    // Second pass: process and generate code
    this.processProgram(this.ast);
    
    // Initialize config from configBlock
    this.config = new Config(this.configBlock);
    
    // Third pass: load .ys modules
    this.loadModules();
    
    return this.buildArduinoCode();
  }

  analyzeAST(node) {
    if (!node) return;
    
    if (node.type === 'CallExpression' && node.callee && node.callee.name === 'print') {
      this.needsSerial = true;
    }
    
    // Recursively check all nodes
    if (Array.isArray(node)) {
      node.forEach(n => this.analyzeAST(n));
    } else if (typeof node === 'object') {
      Object.values(node).forEach(value => {
        if (value && typeof value === 'object') {
          this.analyzeAST(value);
        }
      });
    }
  }

  processProgram(program) {
    for (const stmt of program.body) {
      this.processTopLevelStatement(stmt);
    }
  }

  processTopLevelStatement(stmt) {
    if (stmt.type === 'MainDirective') {
      // Just track it - validation happens at compile time
      return;
    } else if (stmt.type === 'ClassDeclaration') {
      this.classes.push(stmt);
    } else if (stmt.type === 'EnumDeclaration') {
      this.enums.push(stmt);
    } else if (stmt.type === 'StructDeclaration') {
      this.structs.push(stmt);
    } else if (stmt.type === 'FunctionDeclaration') {
      // Special handling for start()/setup() and loop()
      if (stmt.name === 'setup' || stmt.name === 'start') {
        this.setupStatements = stmt.body;
      } else if (stmt.name === 'loop') {
        this.loopStatements = stmt.body;
      } else {
        this.functions.push(stmt);
      }
    } else if (stmt.type === 'VariableDeclaration') {
      this.globalVariables.push(stmt);
    } else if (stmt.type === 'OnBlock') {
      this.onBlocks.push(stmt);
    } else if (stmt.type === 'InterruptBlock') {
      this.interrupts.push(stmt);
    } else if (stmt.type === 'SignalDeclaration') {
      this.signals.push(stmt);
    } else if (stmt.type === 'TaskDeclaration') {
      this.tasks.push(stmt);
    } else if (stmt.type === 'UseStatement') {
      this.useStatements.push(stmt);
    } else if (stmt.type === 'LoadStatement') {
      this.loadStatements.push(stmt);
    } else if (stmt.type === 'AliasStatement') {
      this.aliases.push(stmt);
    } else if (stmt.type === 'ConfigBlock') {
      this.configBlock = stmt;
    } else if (stmt.type === 'ReactDeclaration') {
      this.reactVars.push(stmt);
    }
  }

  loadModules() {
    const fs = require('fs');
    const path = require('path');
    const { Lexer } = require('./lexer');
    const { Parser } = require('./parser');
    
    for (const load of this.loadStatements) {
      if (load.isYsFile) {
        if (!this.fileReader) {
          // No file reader provided - skip silently (likely in tests)
          continue;
        }
        
        try {
          // Construct the path to the .ys file
          const filePath = path.resolve(this.basePath, load.library);
          
          // Read the .ys file
          const moduleSource = this.fileReader(filePath);
          
          // Parse the module
          const lexer = new Lexer(moduleSource);
          const tokens = lexer.tokenize();
          const parser = new Parser(tokens);
          const moduleAst = parser.parse();
          
          // Store the module with its namespace
          this.modules.push({
            name: load.moduleName,
            ast: moduleAst
          });
        } catch (error) {
          // Re-throw the error with more context for production use
          throw new Error(`Failed to load module ${load.library}: ${error.message}`);
        }
      }
    }
  }

  buildArduinoCode() {
    let code = '// Generated by Ypsilon Script Compiler\n';
    code += '// https://github.com/ycharfi09/ypsilon-script\n\n';
    
    // Add Arduino library includes
    code += '#include <Arduino.h>\n';
    
    // Add loaded C++ libraries (not .ys files)
    for (const load of this.loadStatements) {
      if (!load.isYsFile) {
        code += `#include <${load.library}.h>\n`;
      }
    }
    code += '\n';
    
    // Add hardware type helper classes
    code += this.generateHardwareTypeClasses();
    code += '\n';
    
    // Add PWM backend setup if needed
    const pwmBackend = this.config.getPWMBackend();
    const pwmSetup = generatePWMSetup(pwmBackend);
    if (pwmSetup) {
      code += pwmSetup;
      code += '\n';
    }
    
    // Add aliases as #define
    if (this.aliases.length > 0) {
      code += '// Aliases\n';
      for (const alias of this.aliases) {
        code += `#define ${alias.name} ${alias.value}\n`;
      }
      code += '\n';
    }

    // Generate module namespaces for loaded .ys files
    if (this.modules.length > 0) {
      code += '// Module Namespaces\n';
      for (const module of this.modules) {
        code += this.generateModuleNamespace(module);
      }
    }

    // Enum declarations
    if (this.enums.length > 0) {
      code += '// Enum Declarations\n';
      for (const enumDecl of this.enums) {
        code += this.generateEnumDeclaration(enumDecl) + '\n\n';
      }
    }

    // Struct declarations
    if (this.structs.length > 0) {
      code += '// Struct Declarations\n';
      for (const structDecl of this.structs) {
        code += this.generateStructDeclaration(structDecl) + '\n\n';
      }
    }

    // Class declarations
    if (this.classes.length > 0) {
      code += '// Class Declarations\n';
      for (const cls of this.classes) {
        code += this.generateClassDeclaration(cls) + '\n\n';
      }
    }

    // Signals (using volatile bool)
    if (this.signals.length > 0) {
      code += '// Signal Declarations\n';
      for (const signal of this.signals) {
        code += `volatile bool _signal_${signal.name} = false;\n`;
      }
      code += '\n';
    }

    // React variables (using volatile)
    if (this.reactVars.length > 0) {
      code += '// Reactive Variables\n';
      for (const react of this.reactVars) {
        const typeStr = this.mapType(react.varType);
        const constStr = react.isMut ? 'volatile' : 'volatile const';
        const initStr = react.init ? ' = ' + this.generateExpression(react.init) : '';
        code += `${constStr} ${typeStr} ${react.name}${initStr};\n`;
      }
      code += '\n';
    }

    // Global variables
    if (this.globalVariables.length > 0) {
      code += '// Global Variables\n';
      
      // Collect variables used in ISRs
      const isrVariables = new Set();
      for (const interrupt of this.interrupts) {
        const vars = this.collectISRVariables(interrupt.body);
        vars.forEach(v => isrVariables.add(v));
      }
      
      for (const varDecl of this.globalVariables) {
        const isVolatile = isrVariables.has(varDecl.name);
        code += this.generateVariableDeclaration(varDecl, isVolatile) + '\n';
      }
      code += '\n';
    }

    // Task timing variables
    if (this.tasks.length > 0) {
      code += '// Task Timing Variables\n';
      for (const task of this.tasks) {
        if (task.interval) {
          code += `unsigned long _task_${task.name}_last = 0;\n`;
        }
      }
      code += '\n';
    }

    // Function declarations
    if (this.functions.length > 0) {
      code += '// Function Declarations\n';
      for (const func of this.functions) {
        code += this.generateFunctionDeclaration(func) + '\n\n';
      }
    }

    // ISR function declarations
    if (this.interrupts.length > 0) {
      code += '// Interrupt Service Routines\n';
      for (let i = 0; i < this.interrupts.length; i++) {
        code += this.generateISRFunction(this.interrupts[i], i);
      }
    }

    // Setup function
    code += 'void setup() {\n';
    this.indent = 1;
    
    // Add Serial.begin if print() is used
    if (this.needsSerial) {
      code += this.getIndent() + 'Serial.begin(9600);\n';
    }
    
    // Handle on start blocks
    for (const onBlock of this.onBlocks) {
      if (onBlock.event === 'start') {
        for (const stmt of onBlock.body) {
          code += this.generateStatement(stmt);
        }
      }
    }
    
    if (this.setupStatements.length > 0) {
      for (const stmt of this.setupStatements) {
        code += this.generateStatement(stmt);
      }
    }
    
    // Attach interrupts
    if (this.interrupts.length > 0) {
      code += this.getIndent() + '// Attach Interrupts\n';
      for (let i = 0; i < this.interrupts.length; i++) {
        const interrupt = this.interrupts[i];
        const isrName = interrupt.name || `isr_${i}`;
        const mode = this.mapInterruptMode(interrupt.mode);
        const pin = interrupt.pin;
        
        // For Arduino, we need to convert pin to interrupt number
        // digitalPinToInterrupt() is the recommended way
        code += this.getIndent() + `attachInterrupt(digitalPinToInterrupt(${pin}), ${isrName}, ${mode});\n`;
      }
    }
    
    this.indent = 0;
    code += '}\n\n';

    // Loop function
    code += 'void loop() {\n';
    this.indent = 1;
    
    // Handle on loop blocks
    for (const onBlock of this.onBlocks) {
      if (onBlock.event === 'loop') {
        for (const stmt of onBlock.body) {
          code += this.generateStatement(stmt);
        }
      }
    }
    
    // Handle tasks
    for (const task of this.tasks) {
      if (task.interval) {
        code += this.getIndent() + `// Task: ${task.name}\n`;
        code += this.getIndent() + `if (millis() - _task_${task.name}_last >= `;
        code += this.generateTimeValue(task.interval) + ') {\n';
        this.indent++;
        code += this.getIndent() + `_task_${task.name}_last = millis();\n`;
        for (const stmt of task.body) {
          code += this.generateStatement(stmt);
        }
        this.indent--;
        code += this.getIndent() + '}\n';
      } else if (task.isBackground) {
        // Background tasks run in loop
        code += this.getIndent() + `// Background task: ${task.name}\n`;
        for (const stmt of task.body) {
          code += this.generateStatement(stmt);
        }
      }
    }
    
    if (this.loopStatements.length > 0) {
      for (const stmt of this.loopStatements) {
        code += this.generateStatement(stmt);
      }
    }
    this.indent = 0;
    code += '}\n';

    return code;
  }

  generateClassDeclaration(cls) {
    let code = `class ${cls.name} {\n`;
    code += 'public:\n';
    
    // Generate properties
    for (const prop of cls.properties) {
      code += '  ' + this.mapType(prop.propertyType) + ' ' + prop.name;
      if (prop.init) {
        // Note: In-class initialization requires C++11
        code += ' = ' + this.generateExpression(prop.init);
      }
      code += ';\n';
    }
    
    if (cls.properties.length > 0 && (cls.constructor || cls.methods.length > 0)) {
      code += '\n';
    }
    
    // Generate constructor
    if (cls.constructor) {
      code += '  ' + cls.name + '(';
      code += cls.constructor.params.map(p => 
        this.mapType(p.type) + ' ' + p.name
      ).join(', ');
      code += ') {\n';
      
      this.indent = 2;
      for (const stmt of cls.constructor.body) {
        code += this.generateStatement(stmt);
      }
      this.indent = 0;
      
      code += '  }\n';
      
      if (cls.methods.length > 0) {
        code += '\n';
      }
    }
    
    // Generate methods
    for (let i = 0; i < cls.methods.length; i++) {
      const method = cls.methods[i];
      code += '  ' + this.mapType(method.returnType) + ' ' + method.name + '(';
      code += method.params.map(p => 
        this.mapType(p.type) + ' ' + p.name
      ).join(', ');
      code += ') {\n';
      
      this.indent = 2;
      for (const stmt of method.body) {
        code += this.generateStatement(stmt);
      }
      this.indent = 0;
      
      code += '  }';
      if (i < cls.methods.length - 1) {
        code += '\n\n';
      } else {
        code += '\n';
      }
    }
    
    code += '};';
    return code;
  }

  generateFunctionDeclaration(func) {
    const returnType = this.mapType(func.returnType);
    
    let code = `${returnType} ${func.name}(`;
    code += func.params.map(p => 
      this.mapType(p.type) + ' ' + p.name
    ).join(', ');
    code += ') {\n';
    
    this.indent++;
    for (const stmt of func.body) {
      code += this.generateStatement(stmt);
    }
    this.indent--;
    
    code += '}';
    return code;
  }

  mapType(type) {
    const typeMap = {
      'int': 'int',
      'float': 'float',
      'bool': 'bool',
      'string': 'String',
      'void': 'void',
      'Digital': 'Digital',
      'Analog': 'Analog',
      'PWM': 'PWM',
      'List': 'std::vector',  // We'll need to handle generic types better
      'Map': 'std::map'       // We'll need to handle generic types better
    };
    // If it's not a built-in type, assume it's a class name
    return typeMap[type] || type;
  }

  generateStatement(stmt) {
    switch (stmt.type) {
      case 'VariableDeclaration':
        return this.getIndent() + this.generateVariableDeclaration(stmt) + '\n';
      case 'ExpressionStatement':
        return this.getIndent() + this.generateExpression(stmt.expression) + ';\n';
      case 'IfStatement':
        return this.generateIfStatement(stmt);
      case 'WhileStatement':
        return this.generateWhileStatement(stmt);
      case 'ForStatement':
        return this.generateForStatement(stmt);
      case 'RepeatStatement':
        return this.generateRepeatStatement(stmt);
      case 'ReturnStatement':
        return this.generateReturnStatement(stmt);
      case 'MatchStatement':
        return this.generateMatchStatement(stmt);
      case 'SwitchStatement':
        return this.generateSwitchStatement(stmt);
      case 'EmitStatement':
        return this.generateEmitStatement(stmt);
      case 'WaitStatement':
        return this.generateWaitStatement(stmt);
      case 'TimeoutStatement':
        return this.generateTimeoutStatement(stmt);
      case 'AtomicBlock':
        return this.generateAtomicBlock(stmt);
      case 'CppBlock':
        return this.generateCppBlock(stmt);
      default:
        return '';
    }
  }

  generateVariableDeclaration(varDecl, isVolatile = false) {
    const typePrefix = varDecl.kind === 'const' ? 'const ' : '';
    const volatilePrefix = isVolatile && varDecl.kind !== 'const' ? 'volatile ' : '';
    const type = this.mapType(varDecl.varType);
    let code = `${typePrefix}${volatilePrefix}${type} ${varDecl.name}`;
    if (varDecl.init) {
      let initValue = this.generateExpression(varDecl.init);
      
      // If there's a range constraint, add compile-time or runtime checking
      if (varDecl.range) {
        const minVal = this.generateExpression(varDecl.range.min);
        const maxVal = this.generateExpression(varDecl.range.max);
        // Add a constrained function to ensure the value is in range
        initValue = `constrain(${initValue}, ${minVal}, ${maxVal})`;
      }
      
      code += ' = ' + initValue;
    }
    return code + ';';
  }

  generateIfStatement(stmt) {
    let code = this.getIndent() + 'if (' + this.generateExpression(stmt.test) + ') {\n';
    this.indent++;
    for (const s of stmt.consequent) {
      code += this.generateStatement(s);
    }
    this.indent--;
    code += this.getIndent() + '}';
    
    if (stmt.alternate) {
      code += ' else {\n';
      this.indent++;
      for (const s of stmt.alternate) {
        code += this.generateStatement(s);
      }
      this.indent--;
      code += this.getIndent() + '}';
    }
    
    code += '\n';
    return code;
  }

  generateWhileStatement(stmt) {
    let code = this.getIndent() + 'while (' + this.generateExpression(stmt.test) + ') {\n';
    this.indent++;
    for (const s of stmt.body) {
      code += this.generateStatement(s);
    }
    this.indent--;
    code += this.getIndent() + '}\n';
    return code;
  }

  generateForStatement(stmt) {
    const varType = this.mapType(stmt.varType);
    const init = this.generateExpression(stmt.init);
    const test = this.generateExpression(stmt.test);
    const update = this.generateExpression(stmt.update);
    
    let code = this.getIndent() + `for (${varType} ${stmt.variable} = ${init}; ${test}; ${update}) {\n`;
    
    this.indent++;
    for (const s of stmt.body) {
      code += this.generateStatement(s);
    }
    this.indent--;
    code += this.getIndent() + '}\n';
    return code;
  }

  generateRepeatStatement(stmt) {
    const count = this.generateExpression(stmt.count);
    
    // Generate a for loop: for (int _repeat_i = 0; _repeat_i < count; _repeat_i++)
    let code = this.getIndent() + `for (int _repeat_i = 0; _repeat_i < ${count}; _repeat_i++) {\n`;
    
    this.indent++;
    for (const s of stmt.body) {
      code += this.generateStatement(s);
    }
    this.indent--;
    code += this.getIndent() + '}\n';
    return code;
  }

  generateReturnStatement(stmt) {
    let code = this.getIndent() + 'return';
    if (stmt.argument) {
      code += ' ' + this.generateExpression(stmt.argument);
    }
    return code + ';\n';
  }

  generateExpression(expr) {
    switch (expr.type) {
      case 'Literal':
        return this.generateLiteral(expr);
      case 'Identifier':
        return expr.name;
      case 'BinaryExpression':
        return this.generateBinaryExpression(expr);
      case 'UnaryExpression':
        return this.generateUnaryExpression(expr);
      case 'AssignmentExpression':
        return this.generateExpression(expr.left) + ' = ' + this.generateExpression(expr.right);
      case 'CallExpression':
        return this.generateCallExpression(expr);
      case 'MemberExpression':
        return this.generateMemberExpression(expr);
      case 'ThisExpression':
        return 'this';
      case 'NewExpression':
        return this.generateNewExpression(expr);
      case 'TypeConversion':
        return this.generateTypeConversion(expr);
      case 'ErrorHandling':
        return this.generateErrorHandling(expr);
      default:
        return '';
    }
  }

  generateMemberExpression(expr) {
    const object = this.generateExpression(expr.object);
    // Use -> for pointer access (this is a pointer in C++)
    if (expr.object.type === 'ThisExpression') {
      return `this->${expr.property}`;
    }
    
    // Check if object is a potential module namespace (single identifier)
    if (expr.object.type === 'Identifier') {
      // Check if this identifier is a loaded module
      const isModule = this.modules.some(m => m.name === expr.object.name);
      if (isModule) {
        return `${object}::${expr.property}`;
      }
    }
    
    return `${object}.${expr.property}`;
  }

  generateLiteral(expr) {
    if (expr.valueType === 'string') {
      return `"${expr.value}"`;
    } else if (expr.valueType === 'boolean') {
      return expr.value ? 'true' : 'false';
    }
    
    // Handle numeric literals with units
    if (expr.unit) {
      return String(this.convertUnitToValue(expr.value, expr.unit));
    }
    
    return String(expr.value);
  }
  
  // Convert unit values to raw integers
  convertUnitToValue(value, unit) {
    const unitConversions = {
      // Time units (convert to milliseconds)
      'us': value / 1000,
      'ms': value,
      's': value * 1000,
      'min': value * 60000,
      'h': value * 3600000,
      
      // Frequency units (convert to Hz)
      'Hz': value,
      'kHz': value * 1000,
      'MHz': value * 1000000,
      
      // Angle units (convert to raw integer degrees)
      'deg': value,
      'rad': value * (180 / Math.PI),
      
      // Distance units (convert to millimeters)
      'mm': value,
      'cm': value * 10,
      'm': value * 1000,
      'km': value * 1000000,
      
      // Speed units (RPM as-is)
      'rpm': value
    };
    
    return unitConversions[unit] !== undefined ? unitConversions[unit] : value;
  }

  generateBinaryExpression(expr) {
    const left = this.generateExpression(expr.left);
    const right = this.generateExpression(expr.right);
    
    // Convert operators to C++
    const operatorMap = {
      'and': '&&',
      'or': '||',
      '==': '==',
      '!=': '!=',
      '<': '<',
      '>': '>',
      '<=': '<=',
      '>=': '>=',
      '+': '+',
      '-': '-',
      '*': '*',
      '/': '/',
      '%': '%'
    };
    
    const op = operatorMap[expr.operator] || expr.operator;
    return `(${left} ${op} ${right})`;
  }

  generateUnaryExpression(expr) {
    const operatorMap = {
      'not': '!',
      '-': '-'
    };
    const op = operatorMap[expr.operator] || expr.operator;
    return `${op}(${this.generateExpression(expr.argument)})`;
  }

  generateCallExpression(expr) {
    // Safely extract callee name, checking for null
    if (!expr.callee) {
      return '';
    }
    
    let callee;
    if (expr.callee.type === 'MemberExpression') {
      callee = this.generateExpression(expr.callee);
    } else {
      callee = expr.callee.name || this.generateExpression(expr.callee);
    }
    
    const args = expr.arguments.map(arg => this.generateExpression(arg)).join(', ');
    
    // Map built-in functions to Arduino equivalents
    const builtinMap = {
      'print': 'Serial.println',
      'delay': 'delay',
      'millis': 'millis',
      'pinMode': 'pinMode',
      'digitalWrite': 'digitalWrite',
      'digitalRead': 'digitalRead',
      'analogRead': 'analogRead',
      'analogWrite': 'analogWrite'
    };
    
    const funcName = builtinMap[callee] || callee;
    
    // Mark that we need Serial if print is used
    if (callee === 'print') {
      this.needsSerial = true;
    }
    
    return `${funcName}(${args})`;
  }

  generateNewExpression(expr) {
    const args = expr.arguments.map(arg => this.generateExpression(arg)).join(', ');
    return `${expr.className}(${args})`;
  }

  getIndent() {
    return '  '.repeat(this.indent);
  }

  // Generate enum declaration
  generateEnumDeclaration(enumDecl) {
    let code = `enum ${enumDecl.name} {\n`;
    code += '  ' + enumDecl.values.join(',\n  ') + '\n';
    code += '};';
    return code;
  }

  // Generate struct declaration
  generateStructDeclaration(structDecl) {
    let code = `struct ${structDecl.name} {\n`;
    for (const field of structDecl.fields) {
      code += `  ${this.mapType(field.type)} ${field.name};\n`;
    }
    code += '};';
    return code;
  }

  // Generate module namespace for .ys files
  generateModuleNamespace(module) {
    let code = `namespace ${module.name} {\n`;
    
    // Process all declarations in the module
    const moduleClasses = [];
    const moduleEnums = [];
    const moduleStructs = [];
    const moduleFunctions = [];
    const moduleGlobalVars = [];
    
    for (const stmt of module.ast.body) {
      if (stmt.type === 'ClassDeclaration') {
        moduleClasses.push(stmt);
      } else if (stmt.type === 'EnumDeclaration') {
        moduleEnums.push(stmt);
      } else if (stmt.type === 'StructDeclaration') {
        moduleStructs.push(stmt);
      } else if (stmt.type === 'FunctionDeclaration') {
        moduleFunctions.push(stmt);
      } else if (stmt.type === 'VariableDeclaration') {
        moduleGlobalVars.push(stmt);
      }
    }
    
    // Generate enums
    for (const enumDecl of moduleEnums) {
      code += '  ' + this.generateEnumDeclaration(enumDecl).replace(/\n/g, '\n  ') + '\n\n';
    }
    
    // Generate structs
    for (const structDecl of moduleStructs) {
      code += '  ' + this.generateStructDeclaration(structDecl).replace(/\n/g, '\n  ') + '\n\n';
    }
    
    // Generate classes
    for (const cls of moduleClasses) {
      code += '  ' + this.generateClassDeclaration(cls).replace(/\n/g, '\n  ') + '\n\n';
    }
    
    // Generate global variables
    for (const varDecl of moduleGlobalVars) {
      code += '  ' + this.generateVariableDeclaration(varDecl).replace(/\n/g, '\n  ') + '\n';
    }
    
    // Generate functions
    for (const func of moduleFunctions) {
      code += '  ' + this.generateFunctionDeclaration(func).replace(/\n/g, '\n  ') + '\n\n';
    }
    
    code += '}\n\n';
    return code;
  }

  // Generate match statement (transpile to if-else chain)
  generateMatchStatement(stmt) {
    let code = '';
    let isFirst = true;
    
    for (const matchCase of stmt.cases) {
      if (matchCase.pattern.type === 'Wildcard') {
        // This is the default case
        if (!isFirst) {
          code += this.getIndent() + '} else {\n';
        } else {
          code += this.getIndent() + '{\n';
        }
        this.indent++;
        for (const s of matchCase.consequent) {
          code += this.generateStatement(s);
        }
        this.indent--;
        // Don't add closing brace here - it's added at the end
      } else {
        const condition = `${this.generateExpression(stmt.discriminant)} == ${this.generateExpression(matchCase.pattern)}`;
        if (isFirst) {
          code += this.getIndent() + `if (${condition}) {\n`;
          isFirst = false;
        } else {
          code += this.getIndent() + `} else if (${condition}) {\n`;
        }
        this.indent++;
        for (const s of matchCase.consequent) {
          code += this.generateStatement(s);
        }
        this.indent--;
      }
    }
    
    // Always add final closing brace
    code += this.getIndent() + '}\n';
    
    return code;
  }

  // Generate switch statement
  generateSwitchStatement(stmt) {
    let code = this.getIndent() + `switch (${this.generateExpression(stmt.discriminant)}) {\n`;
    
    for (const caseStmt of stmt.cases) {
      code += this.getIndent() + `  case ${this.generateExpression(caseStmt.test)}:\n`;
      this.indent += 2;
      for (const s of caseStmt.consequent) {
        code += this.generateStatement(s);
      }
      code += this.getIndent() + 'break;\n';
      this.indent -= 2;
    }
    
    if (stmt.defaultCase) {
      code += this.getIndent() + '  default:\n';
      this.indent += 2;
      for (const s of stmt.defaultCase) {
        code += this.generateStatement(s);
      }
      code += this.getIndent() + 'break;\n';
      this.indent -= 2;
    }
    
    code += this.getIndent() + '}\n';
    return code;
  }

  // Generate emit statement
  generateEmitStatement(stmt) {
    return this.getIndent() + `_signal_${stmt.signal} = true;\n`;
  }

  // Generate wait statement
  generateWaitStatement(stmt) {
    const delayValue = this.generateTimeValue(stmt.duration);
    return this.getIndent() + `delay(${delayValue});\n`;
  }

  // Generate timeout statement
  generateTimeoutStatement(stmt) {
    const timeoutMs = this.generateTimeValue(stmt.duration);
    const timeVar = `_timeout_${this.timeVarCounter++}`;
    
    let code = this.getIndent() + `unsigned long ${timeVar} = millis();\n`;
    code += this.getIndent() + `while (millis() - ${timeVar} < ${timeoutMs}) {\n`;
    this.indent++;
    for (const s of stmt.body) {
      code += this.generateStatement(s);
    }
    this.indent--;
    code += this.getIndent() + '}\n';
    
    return code;
  }

  // Generate atomic block (use ATOMIC_BLOCK macro or cli/sei)
  generateAtomicBlock(stmt) {
    let code = this.getIndent() + 'noInterrupts();\n';
    for (const s of stmt.body) {
      code += this.generateStatement(s);
    }
    code += this.getIndent() + 'interrupts();\n';
    return code;
  }

  // Generate C++ inline block
  generateCppBlock(stmt) {
    // For C++ blocks, we just output the statements as-is
    // This is a simplified version - in a full implementation,
    // you might want to handle raw C++ code differently
    let code = this.getIndent() + '// Inline C++\n';
    for (const s of stmt.body) {
      code += this.generateStatement(s);
    }
    return code;
  }

  // Helper to convert time literals to milliseconds
  generateTimeValue(expr) {
    if (expr.type === 'Literal' && expr.unit) {
      const value = expr.value;
      switch (expr.unit) {
        case 'ms':
          return String(value);
        case 's':
          return String(value * 1000);
        case 'us':
          return String(value / 1000);
        case 'min':
          return String(value * 60000);
        case 'h':
          return String(value * 3600000);
        default:
          return String(value);
      }
    }
    return this.generateExpression(expr);
  }

  // Helper to collect variables used in interrupt blocks
  collectISRVariables(body) {
    const variables = new Set();
    
    const collectFromNode = (node) => {
      if (!node) return;
      
      if (node.type === 'Identifier') {
        variables.add(node.name);
      } else if (node.type === 'AssignmentExpression') {
        collectFromNode(node.left);
        collectFromNode(node.right);
      } else if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
        collectFromNode(node.left);
        collectFromNode(node.right);
      } else if (node.type === 'ExpressionStatement') {
        collectFromNode(node.expression);
      } else if (node.type === 'CallExpression') {
        if (node.callee) collectFromNode(node.callee);
        if (node.arguments) {
          node.arguments.forEach(arg => collectFromNode(arg));
        }
      } else if (Array.isArray(node)) {
        node.forEach(n => collectFromNode(n));
      }
    };
    
    collectFromNode(body);
    return Array.from(variables);
  }

  // Helper to validate ISR block for forbidden operations
  validateISRBlock(block) {
    const forbiddenOps = [];
    
    const checkStatement = (stmt) => {
      if (!stmt) return;
      
      // Check for forbidden operations
      if (stmt.type === 'CallExpression') {
        const funcName = stmt.callee?.name;
        if (funcName === 'print') {
          forbiddenOps.push('print() is not allowed in interrupts');
        } else if (funcName === 'delay') {
          forbiddenOps.push('delay() is not allowed in interrupts');
        }
      } else if (stmt.type === 'ExpressionStatement' && stmt.expression?.type === 'CallExpression') {
        const funcName = stmt.expression.callee?.name;
        if (funcName === 'print') {
          forbiddenOps.push('print() is not allowed in interrupts');
        } else if (funcName === 'delay') {
          forbiddenOps.push('delay() is not allowed in interrupts');
        }
      } else if (stmt.type === 'WaitStatement') {
        forbiddenOps.push('wait is not allowed in interrupts');
      } else if (stmt.type === 'WhileStatement' || stmt.type === 'ForStatement') {
        forbiddenOps.push('loops are not allowed in interrupts');
      }
      
      // Recursively check compound statements
      if (stmt.consequent) {
        stmt.consequent.forEach(s => checkStatement(s));
      }
      if (stmt.alternate) {
        stmt.alternate.forEach(s => checkStatement(s));
      }
      if (stmt.body && Array.isArray(stmt.body)) {
        stmt.body.forEach(s => checkStatement(s));
      }
    };
    
    block.forEach(stmt => checkStatement(stmt));
    return forbiddenOps;
  }

  // Generate ISR function code
  generateISRFunction(interrupt, index) {
    // Validate the ISR block
    const errors = this.validateISRBlock(interrupt.body);
    if (errors.length > 0) {
      throw new Error(`Interrupt validation failed:\n${errors.join('\n')}`);
    }
    
    const isrName = interrupt.name || `isr_${index}`;
    let code = `void ${isrName}() {\n`;
    
    this.indent = 1;
    for (const stmt of interrupt.body) {
      code += this.generateStatement(stmt);
    }
    this.indent = 0;
    
    code += '}\n\n';
    return code;
  }

  // Map interrupt mode to Arduino constant
  mapInterruptMode(mode) {
    const modeMap = {
      'rising': 'RISING',
      'falling': 'FALLING',
      'change': 'CHANGE',
      'low': 'LOW',
      'high': 'HIGH'
    };
    return modeMap[mode.toLowerCase()] || 'CHANGE';
  }
  
  // Generate type conversion (.as<type>())
  generateTypeConversion(expr) {
    const sourceExpr = this.generateExpression(expr.expression);
    const targetType = expr.targetType;
    
    // Map YS types to C++ casts
    const typeMap = {
      'int': 'int',
      'float': 'float',
      'bool': 'bool',
      'string': 'String',
      'Digital': 'int',  // Digital to int returns the pin number
      'Analog': 'int',   // Analog to int returns the pin number
      'PWM': 'int'       // PWM to int returns the pin number
    };
    
    const cppType = typeMap[targetType] || targetType;
    return `static_cast<${cppType}>(${sourceExpr})`;
  }
  
  // Generate error handling (!catch blocks)
  generateErrorHandling(expr) {
    // For now, we'll generate a try-catch-like structure
    // In Arduino, we don't have exceptions, so we'll use a simple check
    const exprCode = this.generateExpression(expr.expression);
    
    // Generate the catch block code
    let catchCode = '';
    this.indent++;
    for (const stmt of expr.catchBlock) {
      catchCode += this.generateStatement(stmt);
    }
    this.indent--;
    
    // For simplicity, we'll just execute the expression normally
    // A full implementation would need runtime error checking
    return `(${exprCode})`; // Simplified - actual error handling would be more complex
  }

  // Generate hardware type helper classes (Digital, Analog, PWM)
  generateHardwareTypeClasses() {
    let code = '// Hardware Type Classes\n';
    
    // Digital class
    code += 'class Digital {\n';
    code += 'private:\n';
    code += '  int pin;\n';
    code += '  bool state;\n';
    code += 'public:\n';
    code += '  Digital(int p) : pin(p), state(false) {}\n';
    code += '  void high() { pinMode(pin, OUTPUT); digitalWrite(pin, HIGH); state = true; }\n';
    code += '  void low() { pinMode(pin, OUTPUT); digitalWrite(pin, LOW); state = false; }\n';
    code += '  void toggle() { pinMode(pin, OUTPUT); state = !state; digitalWrite(pin, state ? HIGH : LOW); }\n';
    code += '  bool isHigh() { pinMode(pin, INPUT); return digitalRead(pin) == HIGH; }\n';
    code += '  bool isLow() { pinMode(pin, INPUT); return digitalRead(pin) == LOW; }\n';
    code += '  void write(bool value) { pinMode(pin, OUTPUT); digitalWrite(pin, value ? HIGH : LOW); state = value; }\n';
    code += '  bool read() { pinMode(pin, INPUT); return digitalRead(pin) == HIGH; }\n';
    code += '};\n\n';
    
    // Analog class
    code += 'class Analog {\n';
    code += 'private:\n';
    code += '  int pin;\n';
    code += 'public:\n';
    code += '  Analog(int p) : pin(p) {}\n';
    code += '  int read() { pinMode(pin, INPUT); return analogRead(pin); }\n';
    code += '};\n\n';
    
    // PWM class - board-specific implementation
    const pwmBackend = this.config ? this.config.getPWMBackend() : 'analogWrite';
    if (pwmBackend === 'ledc') {
      // ESP32/ESP8266 LEDC implementation
      code += 'class PWM {\n';
      code += 'private:\n';
      code += '  int pin;\n';
      code += '  int value;\n';
      code += '  int channel;\n';
      code += '  static int nextChannel;\n';
      code += 'public:\n';
      code += '  PWM(int p) : pin(p), value(0) {\n';
      code += '    channel = nextChannel++;\n';
      code += '    ledcSetup(channel, 5000, 8);\n';
      code += '    ledcAttachPin(pin, channel);\n';
      code += '  }\n';
      code += '  void set(int v) { value = v; ledcWrite(channel, v); }\n';
      code += '  int get() { return value; }\n';
      code += '};\n';
      code += 'int PWM::nextChannel = 0;\n\n';
    } else {
      // AVR analogWrite implementation
      code += 'class PWM {\n';
      code += 'private:\n';
      code += '  int pin;\n';
      code += '  int value;\n';
      code += 'public:\n';
      code += '  PWM(int p) : pin(p), value(0) { pinMode(pin, OUTPUT); }\n';
      code += '  void set(int v) { value = v; analogWrite(pin, v); }\n';
      code += '  int get() { return value; }\n';
      code += '};\n\n';
    }
    
    return code;
  }
}

module.exports = { CodeGenerator };

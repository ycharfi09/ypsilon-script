@main

# Complete Ypsilon Script Feature Showcase
# Demonstrates all modern YS features in a single program

# Library loading
load <Servo>

# Aliases for cleaner code
alias LED_RED = 9
alias LED_GREEN = 10
alias BUTTON_PIN = 2

# Configuration
config {
  cpu: atmega328p,
  clock: 16MHz,
  uart: on
}

# Enums for state management
enum SystemMode { IDLE, ACTIVE, EMERGENCY }
enum LedColor { RED, GREEN, YELLOW, OFF }

# Structs for data organization
struct SensorData { 
  temperature: int, 
  humidity: int, 
  pressure: int 
}

# Signals for event communication
signal emergencyDetected
signal buttonPressed

# Reactive variables (volatile for interrupt safety)
react mut interruptCount: int = 0
react mut lastButtonTime: int = 0

# Global state
mut SystemMode currentMode = IDLE
mut LedColor ledState = OFF
mut int loopCounter = 0

# Class definition with modern syntax
class TemperatureSensor {
  mut int currentTemp
  mut int threshold
  
  constructor(int t) {
    self.currentTemp = 0
    self.threshold = t
  }
  
  fn readTemperature() -> int {
    # Simulate reading
    return analogRead(0) / 10
  }
  
  fn isOverheating() -> bool {
    self.currentTemp = self.readTemperature()
    return self.currentTemp > self.threshold
  }
  
  fn getStatus() {
    if (self.isOverheating()) {
      print("OVERHEATING!")
      emit emergencyDetected
    }
  }
}

# Global sensor instance
mut TemperatureSensor tempSensor = new TemperatureSensor(80)

# Modern function with arrow syntax
fn updateLedColor(LedColor color) {
  match color {
    RED => {
      digitalWrite(LED_RED, HIGH)
      digitalWrite(LED_GREEN, LOW)
    },
    GREEN => {
      digitalWrite(LED_RED, LOW)
      digitalWrite(LED_GREEN, HIGH)
    },
    YELLOW => {
      digitalWrite(LED_RED, HIGH)
      digitalWrite(LED_GREEN, HIGH)
    },
    OFF => {
      digitalWrite(LED_RED, LOW)
      digitalWrite(LED_GREEN, LOW)
    }
  }
}

# Inline C++ when needed
fn debugPrint(int value) {
  @cpp {
    print("Debug value: ")
    print(value)
  }
}

# Setup using on start event
on start {
  # Pin configuration
  pinMode(LED_RED, OUTPUT)
  pinMode(LED_GREEN, OUTPUT)
  pinMode(BUTTON_PIN, INPUT_PULLUP)
  
  # Initialize
  currentMode = IDLE
  updateLedColor(GREEN)
  
  print("System initialized")
  print("All features enabled")
}

# Main loop using on loop event
on loop {
  loopCounter = loopCounter + 1
  
  # Read button
  if (digitalRead(BUTTON_PIN) == LOW) {
    atomic {
      # Atomic section for interrupt safety
      lastButtonTime = millis()
      emit buttonPressed
    }
  }
  
  # Check sensor
  tempSensor.getStatus()
  
  # State machine with match
  match currentMode {
    IDLE => {
      ledState = GREEN
      if (loopCounter > 100) {
        currentMode = ACTIVE
      }
    },
    ACTIVE => {
      ledState = YELLOW
      # Check for emergency
      if (tempSensor.isOverheating()) {
        currentMode = EMERGENCY
      }
    },
    EMERGENCY => {
      ledState = RED
      print("EMERGENCY MODE")
    }
  }
  
  updateLedColor(ledState)
  wait 10ms
}

# Periodic task - blink indicator
task blinkStatus every 500ms {
  mut int brightness = analogRead(1) / 4
  analogWrite(LED_GREEN, brightness)
  wait 250ms
  analogWrite(LED_GREEN, 0)
}

# Background task - monitor system
task monitorSystem background {
  if (millis() % 5000 == 0) {
    debugPrint(loopCounter)
    debugPrint(tempSensor.currentTemp)
  }
  wait 100ms
}

# Timeout example
fn connectWithTimeout() -> bool {
  timeout 5s {
    # Simulated connection attempt
    wait 100ms
  }
  return true
}

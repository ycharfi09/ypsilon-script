@main

# Modern Ypsilon Script Syntax Demo
# Showcases all new features: fn, mut, self, enum, struct, match, on blocks, hardware types, repeat

load <servo>

# Config block
config {
  board: arduino_uno,
  clock: 16MHz,
  uart: on,
  port: auto
}

# Hardware types with automatic setup
mut Led statusLed = new Led(13)
mut Button modeButton = new Button(2)
mut Analog sensor = new Analog(0)

# Enum for robot modes
enum RobotMode { AUTO, MANUAL, CALIBRATE }

# Struct for position - NEW SYNTAX (type name instead of name: type)
struct Position {
  int x
  int y
  int z
}

# Signal declarations
signal buttonPressed
signal calibrationDone

# Reactive variables
react mut int sensorValue = 0
react mut int timestamp = 0

# Global state
mut RobotMode mode = AUTO

# Modern class with fn and self
class Servo {
  mut int angle
  mut int pin
  
  constructor(int p) {
    self.pin = p
    self.angle = 90
  }
  
  fn setAngle(int a) -> bool {
    if (a >= 0 and a <= 180) {
      self.angle = a
      return true
    }
    return false
  }
  
  fn getAngle() -> int {
    return self.angle
  }
}

mut Servo armServo = new Servo(9)
mut Servo gripperServo = new Servo(10)

# Modern function with arrow syntax
fn calculateDistance(int x1, int y1, int x2, int y2) -> float {
  mut int dx = x2 - x1
  mut int dy = y2 - y1
  return 0.0  # Would use sqrt in real code
}

fn updateLED() {
  match mode {
    AUTO => {
      statusLed.on()
      wait 200ms
    },
    MANUAL => {
      statusLed.off()
    },
    CALIBRATE => {
      # Blink rapidly during calibration using repeat
      repeat(2) {
        statusLed.toggle()
        wait 50ms
      }
    }
  }
}

# Setup using "on start" event block
on start {
  # No pinMode needed - hardware types handle it
  
  armServo.setAngle(90)
  gripperServo.setAngle(45)
  
  print("Robot initialized")
  print("Hardware types active")
}

# Main loop using "on loop" event block
on loop {
  # Read sensor value atomically
  atomic {
    sensorValue = sensor.read()
    timestamp = millis()
  }
  
  # Handle button press with hardware type
  if (modeButton.justPressed()) {
    emit buttonPressed
    # Cycle through modes
    match mode {
      AUTO => mode = MANUAL,
      MANUAL => mode = CALIBRATE,
      CALIBRATE => mode = AUTO
    }
    print("Mode changed")
  }
  
  # Update robot based on mode
  switch mode {
    case AUTO {
      # Automatic mode logic
      if (sensorValue > 512) {
        armServo.setAngle(120)
      } else {
        armServo.setAngle(60)
      }
    }
    case MANUAL {
      # Manual control - do nothing
    }
    default {
      # Calibration or other modes
      print("Calibrating...")
    }
  }
  
  updateLED()
  wait 10ms
}

# Background task for monitoring
task monitor background {
  if (millis() % 5000 == 0) {
    print("Status OK")
  }
}

# Periodic task for sensor reading with hardware type
task readSensors every 100ms {
  mut Analog tempSensor = new Analog(1)
  mut int temp = tempSensor.read()
  if (temp > 700) {
    print("Temperature high!")
  }
}

# Timeout example in a function
fn connectWifi() -> bool {
  timeout 5s {
    # Connection code would go here
    wait 100ms
  }
  return true
}

# Inline C++ when needed
fn debugOutput() {
  @cpp {
    print("Direct C++ output")
  }
}
